#include "git_utils.h"
#include "file_utils.h"
#include "string_utils.h"
#include <spdlog/spdlog.h>
#include <fmt/format.h>
#include <cstdlib>
#include <sstream>
#include <algorithm>
#include <chrono>
#include <ctime>

#ifdef _WIN32
#include <windows.h>
#else
#include <sys/wait.h>
#include <unistd.h>
#endif

namespace utils {

bool GitUtils::initializeRepository(const std::filesystem::path& projectPath) {
    try {
        if (isGitRepository(projectPath)) {
            spdlog::info("Git repository already exists at {}", projectPath.string());
            return true;
        }
        
        if (!hasGitInstalled()) {
            spdlog::error("Git is not installed or not found in PATH");
            return false;
        }
        
        // Initialize repository
        if (!executeGitCommand(projectPath, {"init"})) {
            spdlog::error("Failed to initialize Git repository");
            return false;
        }
        
        spdlog::info("Git repository initialized at {}", projectPath.string());
        return true;
        
    } catch (const std::exception& e) {
        spdlog::error("Error initializing Git repository: {}", e.what());
        return false;
    }
}

bool GitUtils::isGitRepository(const std::filesystem::path& path) {
    auto gitDir = path / ".git";
    return std::filesystem::exists(gitDir);
}

bool GitUtils::hasGitInstalled() {
    std::string output;
    return executeGitCommand(std::filesystem::current_path(), {"--version"}, &output);
}

bool GitUtils::createGitignore(const std::filesystem::path& projectPath,
                              const std::string& templateType,
                              const std::string& buildSystem,
                              const std::string& packageManager) {
    try {
        std::ostringstream gitignoreContent;

        // Header comment with timestamp
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        gitignoreContent << "# Generated by CPP-Scaffold on " << std::ctime(&time_t);
        gitignoreContent << "# C++ Project .gitignore for " << templateType << " template\n\n";

        // Base C++ gitignore
        gitignoreContent << getCppGitignoreTemplate() << "\n";

        // Build system specific
        if (buildSystem == "cmake") {
            gitignoreContent << getCMakeGitignoreTemplate() << "\n";
        } else if (buildSystem == "meson") {
            gitignoreContent << getMesonGitignoreTemplate() << "\n";
        } else if (buildSystem == "bazel") {
            gitignoreContent << getBazelGitignoreTemplate() << "\n";
        } else if (buildSystem == "xmake") {
            gitignoreContent << getXMakeGitignoreTemplate() << "\n";
        } else if (buildSystem == "premake") {
            gitignoreContent << getPremakeGitignoreTemplate() << "\n";
        } else if (buildSystem == "ninja") {
            gitignoreContent << getNinjaGitignoreTemplate() << "\n";
        }

        // Package manager specific
        if (packageManager == "vcpkg") {
            gitignoreContent << getVcpkgGitignoreTemplate() << "\n";
        } else if (packageManager == "conan") {
            gitignoreContent << getConanGitignoreTemplate() << "\n";
        } else if (packageManager == "spack") {
            gitignoreContent << getSpackGitignoreTemplate() << "\n";
        } else if (packageManager == "hunter") {
            gitignoreContent << getHunterGitignoreTemplate() << "\n";
        }

        // Template specific
        if (templateType == "qt-app" || templateType == "gui") {
            gitignoreContent << getQtGitignoreTemplate() << "\n";
        } else if (templateType == "sfml-app" || templateType == "gameengine") {
            gitignoreContent << getGameDevGitignoreTemplate() << "\n";
        } else if (templateType == "webservice" || templateType == "network") {
            gitignoreContent << getWebServiceGitignoreTemplate() << "\n";
        } else if (templateType == "embedded") {
            gitignoreContent << getEmbeddedGitignoreTemplate() << "\n";
        } else if (templateType == "lib" || templateType == "header-only-lib") {
            gitignoreContent << getLibraryGitignoreTemplate() << "\n";
        }

        // Editor specific (always include common ones)
        gitignoreContent << getVSCodeGitignoreTemplate() << "\n";
        gitignoreContent << getVisualStudioGitignoreTemplate() << "\n";
        gitignoreContent << getClionGitignoreTemplate() << "\n";
        gitignoreContent << getVimGitignoreTemplate() << "\n";
        gitignoreContent << getEmacsGitignoreTemplate() << "\n";

        // Documentation
        gitignoreContent << getDocumentationGitignoreTemplate() << "\n";

        // Testing frameworks
        gitignoreContent << getTestingGitignoreTemplate() << "\n";

        // CI/CD
        gitignoreContent << getCICDGitignoreTemplate() << "\n";

        // Operating system specific
        gitignoreContent << getOSGitignoreTemplate() << "\n";

        auto gitignorePath = projectPath / ".gitignore";
        if (!FileUtils::writeToFile(gitignorePath.string(), gitignoreContent.str())) {
            spdlog::error("Failed to create .gitignore file");
            return false;
        }

        spdlog::info("Created comprehensive .gitignore file for {} template", templateType);
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating .gitignore: {}", e.what());
        return false;
    }
}

bool GitUtils::configureRepository(const std::filesystem::path& projectPath,
                                  const std::string& userName,
                                  const std::string& userEmail) {
    try {
        if (!userName.empty()) {
            if (!executeGitCommand(projectPath, {"config", "user.name", userName})) {
                spdlog::warn("Failed to set Git user name");
            }
        }
        
        if (!userEmail.empty()) {
            if (!executeGitCommand(projectPath, {"config", "user.email", userEmail})) {
                spdlog::warn("Failed to set Git user email");
            }
        }
        
        // Set default branch name to main
        executeGitCommand(projectPath, {"config", "init.defaultBranch", "main"});
        
        return true;
        
    } catch (const std::exception& e) {
        spdlog::error("Error configuring Git repository: {}", e.what());
        return false;
    }
}

bool GitUtils::createInitialCommit(const std::filesystem::path& projectPath,
                                  const std::string& message) {
    try {
        // Add all files
        if (!executeGitCommand(projectPath, {"add", "."})) {
            spdlog::error("Failed to add files to Git");
            return false;
        }
        
        // Create initial commit
        if (!executeGitCommand(projectPath, {"commit", "-m", message})) {
            spdlog::error("Failed to create initial commit");
            return false;
        }
        
        spdlog::info("Created initial commit: {}", message);
        return true;
        
    } catch (const std::exception& e) {
        spdlog::error("Error creating initial commit: {}", e.what());
        return false;
    }
}

bool GitUtils::createGitAttributes(const std::filesystem::path& projectPath) {
    try {
        auto gitAttributesPath = projectPath / ".gitattributes";
        std::string content = getGitAttributesTemplate();
        
        if (!FileUtils::writeToFile(gitAttributesPath.string(), content)) {
            spdlog::error("Failed to create .gitattributes file");
            return false;
        }
        
        spdlog::info("Created .gitattributes file");
        return true;
        
    } catch (const std::exception& e) {
        spdlog::error("Error creating .gitattributes: {}", e.what());
        return false;
    }
}

bool GitUtils::executeGitCommand(const std::filesystem::path& workingDir,
                                const std::vector<std::string>& args,
                                std::string* output) {
    try {
        (void)workingDir; // TODO: Implement working directory support
        std::ostringstream command;
        command << "git";
        for (const auto& arg : args) {
            command << " \"" << arg << "\"";
        }

        std::string fullCommand = command.str();
        
#ifdef _WIN32
        if (output) {
            fullCommand += " 2>&1";
            FILE* pipe = _popen(fullCommand.c_str(), "r");
            if (!pipe) return false;
            
            char buffer[128];
            std::ostringstream result;
            while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                result << buffer;
            }
            *output = result.str();
            
            int exitCode = _pclose(pipe);
            return exitCode == 0;
        } else {
            int result = std::system(fullCommand.c_str());
            return result == 0;
        }
#else
        // Change to working directory
        auto oldPath = std::filesystem::current_path();
        std::filesystem::current_path(workingDir);
        
        if (output) {
            fullCommand += " 2>&1";
            FILE* pipe = popen(fullCommand.c_str(), "r");
            if (!pipe) {
                std::filesystem::current_path(oldPath);
                return false;
            }
            
            char buffer[128];
            std::ostringstream result;
            while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                result << buffer;
            }
            *output = result.str();
            
            int exitCode = pclose(pipe);
            std::filesystem::current_path(oldPath);
            return WEXITSTATUS(exitCode) == 0;
        } else {
            int result = std::system(fullCommand.c_str());
            std::filesystem::current_path(oldPath);
            return WEXITSTATUS(result) == 0;
        }
#endif
        
    } catch (const std::exception& e) {
        spdlog::error("Error executing Git command: {}", e.what());
        return false;
    }
}

std::string GitUtils::getCppGitignoreTemplate() {
    return R"(# C++ Build artifacts
*.o
*.obj
*.exe
*.dll
*.so
*.dylib
*.a
*.lib
*.exp
*.pdb
*.ilk
*.map

# Compiled Dynamic libraries
*.so.*
*.dylib

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la

# Executables
*.exe
*.out
*.app

# Debug files
*.dSYM/
*.su
*.idb
*.pdb

# Kernel Module Compile Results
*.mod*
*.cmd
.tmp_versions/
modules.order
Module.symvers
Mkfile.old
dkms.conf)";
}

std::string GitUtils::getCMakeGitignoreTemplate() {
    return R"(# CMake
CMakeLists.txt.user
CMakeCache.txt
CMakeFiles/
CMakeScripts/
Testing/
Makefile
cmake_install.cmake
install_manifest.txt
compile_commands.json
CTestTestfile.cmake
_deps/

# CMake build directories
build/
Build/
BUILD/
cmake-build-*/
out/)";
}

std::string GitUtils::getMesonGitignoreTemplate() {
    return R"(# Meson
builddir/
build/
meson-logs/
meson-private/
.mesonpy-*)";
}

std::string GitUtils::getBazelGitignoreTemplate() {
    return R"(# Bazel
bazel-*
.bazelrc.user
.bazelversion)";
}

std::string GitUtils::getVcpkgGitignoreTemplate() {
    return R"(# vcpkg
vcpkg_installed/
.vcpkg-root)";
}

std::string GitUtils::getConanGitignoreTemplate() {
    return R"(# Conan
conandata.yml
conaninfo.txt
conanbuildinfo.*
conan.lock
test_package/build/)";
}

std::string GitUtils::getVSCodeGitignoreTemplate() {
    return R"(# Visual Studio Code
.vscode/
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets

# Local History for Visual Studio Code
.history/

# Built Visual Studio Code Extensions
*.vsix)";
}

std::string GitUtils::getVisualStudioGitignoreTemplate() {
    return R"(# Visual Studio
.vs/
*.vcxproj.user
*.vcxproj.filters
*.VC.db
*.VC.VC.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db-*

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap)";
}

std::string GitUtils::getClionGitignoreTemplate() {
    return R"(# CLion
.idea/
cmake-build-*/)";
}

std::string GitUtils::getQtGitignoreTemplate() {
    return R"(# Qt
*.pro.user
*.pro.user.*
*.qbs.user
*.qbs.user.*
*.moc
moc_*.cpp
moc_*.h
qrc_*.cpp
ui_*.h
*.qmlc
*.jsc
Makefile*
*build-*
*.qm
.qmake.cache
.qmake.stash

# Qt unit tests
target_wrapper.*

# QtCreator
*.autosave

# QtCreator Qml
*.qmlproject.user
*.qmlproject.user.*)";
}

std::string GitUtils::getDocumentationGitignoreTemplate() {
    return R"(# Documentation
docs/_build/
docs/html/
docs/latex/
*.tmp
*.bak
*~

# Doxygen
Doxyfile.bak
html/
latex/)";
}

std::string GitUtils::getGitAttributesTemplate() {
    return R"(# Auto detect text files and perform LF normalization
* text=auto

# C++ source files
*.cpp text diff=cpp
*.c text diff=cpp
*.cc text diff=cpp
*.cxx text diff=cpp
*.h text diff=cpp
*.hpp text diff=cpp
*.hh text diff=cpp
*.hxx text diff=cpp

# CMake files
CMakeLists.txt text
*.cmake text

# Build files
*.mk text
Makefile text
makefile text

# Documentation
*.md text
*.txt text
*.rst text

# Configuration files
*.json text
*.xml text
*.yml text
*.yaml text
*.toml text
*.ini text
*.cfg text

# Scripts
*.sh text eol=lf
*.bat text eol=crlf
*.ps1 text eol=crlf

# Binary files
*.exe binary
*.dll binary
*.so binary
*.dylib binary
*.a binary
*.lib binary
*.o binary
*.obj binary

# Images
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.svg text

# Archives
*.zip binary
*.tar binary
*.gz binary
*.7z binary)";
}

// Code Quality Tools Implementation
bool CodeQualityTools::createClangFormatConfig(const std::filesystem::path& projectPath,
                                              const std::string& style) {
    try {
        auto configPath = projectPath / ".clang-format";
        std::string content = getClangFormatTemplate(style);

        if (!FileUtils::writeToFile(configPath.string(), content)) {
            spdlog::error("Failed to create .clang-format file");
            return false;
        }

        spdlog::info("Created .clang-format configuration");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating clang-format config: {}", e.what());
        return false;
    }
}

bool CodeQualityTools::createClangTidyConfig(const std::filesystem::path& projectPath,
                                            const std::vector<std::string>& checks) {
    try {
        auto configPath = projectPath / ".clang-tidy";
        std::string content = getClangTidyTemplate(checks);

        if (!FileUtils::writeToFile(configPath.string(), content)) {
            spdlog::error("Failed to create .clang-tidy file");
            return false;
        }

        spdlog::info("Created .clang-tidy configuration");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating clang-tidy config: {}", e.what());
        return false;
    }
}

bool CodeQualityTools::createEditorConfig(const std::filesystem::path& projectPath) {
    try {
        auto configPath = projectPath / ".editorconfig";
        std::string content = getEditorConfigTemplate();

        if (!FileUtils::writeToFile(configPath.string(), content)) {
            spdlog::error("Failed to create .editorconfig file");
            return false;
        }

        spdlog::info("Created .editorconfig file");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating .editorconfig: {}", e.what());
        return false;
    }
}

std::string CodeQualityTools::getClangFormatTemplate(const std::string& style) {
    if (style == "Google") {
        return R"(---
Language: Cpp
BasedOnStyle: Google
IndentWidth: 2
TabWidth: 2
UseTab: Never
ColumnLimit: 80
AccessModifierOffset: -1
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: false
AlignConsecutiveDeclarations: false
AlignEscapedNewlines: Left
AlignOperands: true
AlignTrailingComments: true
AllowAllParametersOfDeclarationOnNextLine: true
AllowShortBlocksOnASingleLine: false
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: All
AllowShortIfStatementsOnASingleLine: true
AllowShortLoopsOnASingleLine: true
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: true
AlwaysBreakTemplateDeclarations: true
BinPackArguments: true
BinPackParameters: true
BraceWrapping:
  AfterClass: false
  AfterControlStatement: false
  AfterEnum: false
  AfterFunction: false
  AfterNamespace: false
  AfterObjCDeclaration: false
  AfterStruct: false
  AfterUnion: false
  BeforeCatch: false
  BeforeElse: false
  IndentBraces: false
BreakBeforeBinaryOperators: None
BreakBeforeBraces: Attach
BreakBeforeTernaryOperators: true
BreakConstructorInitializersBeforeComma: false
BreakAfterJavaFieldAnnotations: false
BreakStringLiterals: true
Cpp11BracedListStyle: true
DerivePointerAlignment: true
DisableFormat: false
ExperimentalAutoDetectBinPacking: false
ForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]
IncludeCategories:
  - Regex: '^<.*\.h>'
    Priority: 1
  - Regex: '^<.*'
    Priority: 2
  - Regex: '.*'
    Priority: 3
IncludeIsMainRegex: '([-_](test|unittest))?$'
IndentCaseLabels: true
IndentWrappedFunctionNames: false
KeepEmptyLinesAtTheStartOfBlocks: false
MacroBlockBegin: ''
MacroBlockEnd: ''
MaxEmptyLinesToKeep: 1
NamespaceIndentation: None
ObjCBlockIndentWidth: 2
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: false
PenaltyBreakBeforeFirstCallParameter: 1
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakString: 1000
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 200
PointerAlignment: Left
ReflowComments: true
SortIncludes: true
SpaceAfterCStyleCast: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeParens: ControlStatements
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 2
SpacesInAngles: false
SpacesInContainerLiterals: true
SpacesInCStyleCastParentheses: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
Standard: Auto
TabWidth: 8
UseTab: Never
...)";
    } else if (style == "LLVM") {
        return R"(---
Language: Cpp
BasedOnStyle: LLVM
IndentWidth: 2
TabWidth: 2
UseTab: Never
ColumnLimit: 80
...)";
    } else if (style == "Mozilla") {
        return R"(---
Language: Cpp
BasedOnStyle: Mozilla
IndentWidth: 2
TabWidth: 2
UseTab: Never
ColumnLimit: 80
...)";
    } else {
        // Default to Google style
        return getClangFormatTemplate("Google");
    }
}

std::string CodeQualityTools::getClangTidyTemplate(const std::vector<std::string>& checks) {
    std::ostringstream config;
    config << "---\n";
    config << "Checks: '";

    if (checks.empty()) {
        // Default checks
        config << "clang-diagnostic-*,clang-analyzer-*,cppcoreguidelines-*,modernize-*,performance-*,readability-*";
    } else {
        for (size_t i = 0; i < checks.size(); ++i) {
            if (i > 0) config << ",";
            config << checks[i];
        }
    }

    config << "'\n";
    config << "WarningsAsErrors: ''\n";
    config << "HeaderFilterRegex: ''\n";
    config << "AnalyzeTemporaryDtors: false\n";
    config << "FormatStyle: 'file'\n";
    config << "CheckOptions:\n";
    config << "  - key: readability-identifier-naming.NamespaceCase\n";
    config << "    value: lower_case\n";
    config << "  - key: readability-identifier-naming.ClassCase\n";
    config << "    value: CamelCase\n";
    config << "  - key: readability-identifier-naming.FunctionCase\n";
    config << "    value: camelBack\n";
    config << "  - key: readability-identifier-naming.VariableCase\n";
    config << "    value: camelBack\n";
    config << "  - key: readability-identifier-naming.ConstantCase\n";
    config << "    value: UPPER_CASE\n";
    config << "...\n";

    return config.str();
}

std::string CodeQualityTools::getEditorConfigTemplate() {
    return R"(# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

# All files
[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

# C++ files
[*.{cpp,cc,cxx,c,h,hpp,hh,hxx}]
indent_style = space
indent_size = 2

# CMake files
[{CMakeLists.txt,*.cmake}]
indent_style = space
indent_size = 2

# Python files
[*.py]
indent_style = space
indent_size = 4

# Shell scripts
[*.sh]
indent_style = space
indent_size = 2

# Batch files
[*.{bat,cmd}]
end_of_line = crlf

# Markdown files
[*.md]
trim_trailing_whitespace = false

# JSON files
[*.json]
indent_style = space
indent_size = 2

# YAML files
[*.{yml,yaml}]
indent_style = space
indent_size = 2

# XML files
[*.xml]
indent_style = space
indent_size = 2)";
}

// Enhanced Git workflow support
bool GitUtils::setupGitWorkflow(const std::filesystem::path& projectPath, const std::string& workflowType) {
    if (workflowType == "gitflow") {
        return setupGitFlow(projectPath);
    } else if (workflowType == "github-flow") {
        return setupGitHubFlow(projectPath);
    } else if (workflowType == "gitlab-flow") {
        return setupGitLabFlow(projectPath);
    }
    return true; // For "none" or "custom"
}

bool GitUtils::setupGitFlow(const std::filesystem::path& projectPath) {
    try {
        // Create develop branch
        if (!createBranch(projectPath, "develop")) {
            spdlog::error("Failed to create develop branch for GitFlow");
            return false;
        }

        // Switch to develop branch
        if (!switchBranch(projectPath, "develop")) {
            spdlog::error("Failed to switch to develop branch");
            return false;
        }

        // Create GitFlow configuration
        std::string configContent = getGitFlowConfigTemplate();
        auto configPath = projectPath / ".gitflow";
        if (!FileUtils::writeToFile(configPath.string(), configContent)) {
            spdlog::warn("Failed to create GitFlow configuration file");
        }

        spdlog::info("GitFlow workflow configured successfully");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error setting up GitFlow: {}", e.what());
        return false;
    }
}

bool GitUtils::setupGitHubFlow(const std::filesystem::path& projectPath) {
    try {
        // GitHub Flow uses main branch as the primary branch
        // Create a simple workflow configuration
        std::string configContent = getGitHubFlowConfigTemplate();
        auto configPath = projectPath / ".github" / "workflows";

        if (!std::filesystem::exists(configPath)) {
            std::filesystem::create_directories(configPath);
        }

        auto workflowFile = configPath / "github-flow.yml";
        if (!FileUtils::writeToFile(workflowFile.string(), configContent)) {
            spdlog::warn("Failed to create GitHub Flow workflow file");
        }

        spdlog::info("GitHub Flow workflow configured successfully");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error setting up GitHub Flow: {}", e.what());
        return false;
    }
}

bool GitUtils::setupGitLabFlow(const std::filesystem::path& projectPath) {
    try {
        // Create production and pre-production branches
        if (!createBranch(projectPath, "production")) {
            spdlog::warn("Failed to create production branch for GitLab Flow");
        }

        if (!createBranch(projectPath, "pre-production")) {
            spdlog::warn("Failed to create pre-production branch for GitLab Flow");
        }

        // Create GitLab CI configuration
        std::string configContent = getGitLabFlowConfigTemplate();
        auto configPath = projectPath / ".gitlab-ci.yml";
        if (!FileUtils::writeToFile(configPath.string(), configContent)) {
            spdlog::warn("Failed to create GitLab CI configuration file");
        }

        spdlog::info("GitLab Flow workflow configured successfully");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error setting up GitLab Flow: {}", e.what());
        return false;
    }
}

bool GitUtils::createBranchesFromStrategy(const std::filesystem::path& projectPath,
                                        const std::string& strategy,
                                        const std::vector<std::string>& additionalBranches) {
    try {
        if (strategy == "gitflow") {
            if (!createBranch(projectPath, "develop")) {
                spdlog::error("Failed to create develop branch");
                return false;
            }
        } else if (strategy == "feature") {
            if (!createBranch(projectPath, "develop")) {
                spdlog::error("Failed to create develop branch");
                return false;
            }
        }

        // Create additional branches
        for (const auto& branch : additionalBranches) {
            if (!createBranch(projectPath, branch)) {
                spdlog::warn("Failed to create branch: {}", branch);
            }
        }

        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating branches: {}", e.what());
        return false;
    }
}

// License management
bool GitUtils::createLicenseFile(const std::filesystem::path& projectPath,
                                const std::string& licenseType,
                                const std::string& projectName,
                                const std::string& author,
                                const std::string& year) {
    try {
        std::string licenseContent;
        std::string currentYear = year.empty() ? "2024" : year;
        std::string authorName = author.empty() ? "Project Author" : author;

        if (licenseType == "mit") {
            licenseContent = getMITLicenseTemplate(authorName, currentYear);
        } else if (licenseType == "apache2") {
            licenseContent = getApache2LicenseTemplate(authorName, currentYear);
        } else if (licenseType == "gpl3") {
            licenseContent = getGPL3LicenseTemplate(authorName, currentYear);
        } else if (licenseType == "bsd3") {
            licenseContent = getBSD3LicenseTemplate(authorName, currentYear);
        } else if (licenseType == "bsd2") {
            licenseContent = getBSD2LicenseTemplate(authorName, currentYear);
        } else if (licenseType == "unlicense") {
            licenseContent = getUnlicenseTemplate();
        } else if (licenseType == "none") {
            return true; // No license file needed
        } else {
            spdlog::warn("Unknown license type: {}", licenseType);
            return false;
        }

        auto licensePath = projectPath / "LICENSE";
        if (!FileUtils::writeToFile(licensePath.string(), licenseContent)) {
            spdlog::error("Failed to create LICENSE file");
            return false;
        }

        spdlog::info("License file created: {}", licenseType);
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating license file: {}", e.what());
        return false;
    }
}

// Enhanced repository configuration
bool GitUtils::configureRepositoryAdvanced(const std::filesystem::path& projectPath,
                                          const std::string& userName,
                                          const std::string& userEmail,
                                          const std::string& remoteUrl,
                                          bool setupHooks) {
    try {
        // Configure user name and email if provided
        if (!userName.empty()) {
            if (!executeGitCommand(projectPath, {"config", "user.name", userName})) {
                spdlog::warn("Failed to set Git user name");
            }
        }

        if (!userEmail.empty()) {
            if (!executeGitCommand(projectPath, {"config", "user.email", userEmail})) {
                spdlog::warn("Failed to set Git user email");
            }
        }

        // Add remote if provided
        if (!remoteUrl.empty()) {
            if (!addRemote(projectPath, "origin", remoteUrl)) {
                spdlog::warn("Failed to add remote origin");
            }
        }

        // Setup Git hooks if requested
        if (setupHooks) {
            createPreCommitHook(projectPath);
            createPrePushHook(projectPath);
            createCommitMsgHook(projectPath);
        }

        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error configuring repository: {}", e.what());
        return false;
    }
}

// Git hooks management
bool GitUtils::createPreCommitHook(const std::filesystem::path& projectPath) {
    try {
        auto hooksDir = projectPath / ".git" / "hooks";
        if (!std::filesystem::exists(hooksDir)) {
            std::filesystem::create_directories(hooksDir);
        }

        auto hookFile = hooksDir / "pre-commit";
        std::string hookContent = getPreCommitHookTemplate();

        if (!FileUtils::writeToFile(hookFile.string(), hookContent)) {
            spdlog::error("Failed to create pre-commit hook");
            return false;
        }

        // Make the hook executable on Unix systems
#ifndef _WIN32
        std::filesystem::permissions(hookFile, std::filesystem::perms::owner_exec |
                                              std::filesystem::perms::group_exec |
                                              std::filesystem::perms::others_exec,
                                              std::filesystem::perm_options::add);
#endif

        spdlog::info("Pre-commit hook created");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating pre-commit hook: {}", e.what());
        return false;
    }
}

bool GitUtils::createPrePushHook(const std::filesystem::path& projectPath) {
    try {
        auto hooksDir = projectPath / ".git" / "hooks";
        if (!std::filesystem::exists(hooksDir)) {
            std::filesystem::create_directories(hooksDir);
        }

        auto hookFile = hooksDir / "pre-push";
        std::string hookContent = getPrePushHookTemplate();

        if (!FileUtils::writeToFile(hookFile.string(), hookContent)) {
            spdlog::error("Failed to create pre-push hook");
            return false;
        }

        // Make the hook executable on Unix systems
#ifndef _WIN32
        std::filesystem::permissions(hookFile, std::filesystem::perms::owner_exec |
                                              std::filesystem::perms::group_exec |
                                              std::filesystem::perms::others_exec,
                                              std::filesystem::perm_options::add);
#endif

        spdlog::info("Pre-push hook created");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating pre-push hook: {}", e.what());
        return false;
    }
}

bool GitUtils::createCommitMsgHook(const std::filesystem::path& projectPath) {
    try {
        auto hooksDir = projectPath / ".git" / "hooks";
        if (!std::filesystem::exists(hooksDir)) {
            std::filesystem::create_directories(hooksDir);
        }

        auto hookFile = hooksDir / "commit-msg";
        std::string hookContent = getCommitMsgHookTemplate();

        if (!FileUtils::writeToFile(hookFile.string(), hookContent)) {
            spdlog::error("Failed to create commit-msg hook");
            return false;
        }

        // Make the hook executable on Unix systems
#ifndef _WIN32
        std::filesystem::permissions(hookFile, std::filesystem::perms::owner_exec |
                                              std::filesystem::perms::group_exec |
                                              std::filesystem::perms::others_exec,
                                              std::filesystem::perm_options::add);
#endif

        spdlog::info("Commit-msg hook created");
        return true;

    } catch (const std::exception& e) {
        spdlog::error("Error creating commit-msg hook: {}", e.what());
        return false;
    }
}

// License templates
std::string GitUtils::getMITLicenseTemplate(const std::string& author, const std::string& year) {
    return fmt::format(R"(MIT License

Copyright (c) {} {}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.)", year, author);
}

std::string GitUtils::getApache2LicenseTemplate(const std::string& author, const std::string& year) {
    return fmt::format(R"(Apache License
Version 2.0, January 2004
http://www.apache.org/licenses/

Copyright {} {}

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.)", year, author);
}

std::string GitUtils::getGPL3LicenseTemplate(const std::string& author, const std::string& year) {
    return fmt::format(R"(GNU GENERAL PUBLIC LICENSE
Version 3, 29 June 2007

Copyright (C) {} {}

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.)", year, author);
}

std::string GitUtils::getBSD3LicenseTemplate(const std::string& author, const std::string& year) {
    return fmt::format(R"(BSD 3-Clause License

Copyright (c) {}, {}
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.)", year, author);
}

std::string GitUtils::getBSD2LicenseTemplate(const std::string& author, const std::string& year) {
    return fmt::format(R"(BSD 2-Clause License

Copyright (c) {}, {}
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.)", year, author);
}

std::string GitUtils::getUnlicenseTemplate() {
    return R"(This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>)";
}

// Git workflow configuration templates
std::string GitUtils::getGitFlowConfigTemplate() {
    return R"([gitflow "branch"]
    master = main
    develop = develop

[gitflow "prefix"]
    feature = feature/
    bugfix = bugfix/
    release = release/
    hotfix = hotfix/
    support = support/
    versiontag = v

[gitflow "path"]
    hooks = .git/hooks)";
}

std::string GitUtils::getGitHubFlowConfigTemplate() {
    return R"(name: GitHub Flow CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Configure CMake
      run: cmake -B ${{github.workspace}}/build -DCMAKE_BUILD_TYPE=Release

    - name: Build
      run: cmake --build ${{github.workspace}}/build --config Release

    - name: Test
      working-directory: ${{github.workspace}}/build
      run: ctest -C Release)";
}

std::string GitUtils::getGitLabFlowConfigTemplate() {
    return R"(stages:
  - build
  - test
  - deploy

variables:
  CMAKE_BUILD_TYPE: Release

build:
  stage: build
  script:
    - mkdir build
    - cd build
    - cmake .. -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE
    - make -j$(nproc)
  artifacts:
    paths:
      - build/
    expire_in: 1 hour

test:
  stage: test
  script:
    - cd build
    - ctest --output-on-failure
  dependencies:
    - build

deploy:
  stage: deploy
  script:
    - echo "Deploying application..."
  only:
    - production)";
}

// Additional build system templates
std::string GitUtils::getXMakeGitignoreTemplate() {
    return R"(# XMake build system
.xmake/
build/
.cache/
compile_commands.json)";
}

std::string GitUtils::getPremakeGitignoreTemplate() {
    return R"(# Premake build system
*.vcxproj
*.vcxproj.filters
*.vcxproj.user
*.sln
*.suo
*.user
*.userosscache
*.sln.docstates
Makefile
*.make
obj/)";
}

std::string GitUtils::getNinjaGitignoreTemplate() {
    return R"(# Ninja build system
build.ninja
.ninja_deps
.ninja_log)";
}

// Additional package manager templates
std::string GitUtils::getSpackGitignoreTemplate() {
    return R"(# Spack package manager
spack-build*/
.spack-env/
spack.lock)";
}

std::string GitUtils::getHunterGitignoreTemplate() {
    return R"(# Hunter package manager
_builds/
_install/
_deps/
.hunter/
hunter_install/)";
}

// Additional editor templates
std::string GitUtils::getVimGitignoreTemplate() {
    return R"(# Vim editor
*.swp
*.swo
*~
.vimrc.local
.viminfo
Session.vim)";
}

std::string GitUtils::getEmacsGitignoreTemplate() {
    return R"(# Emacs editor
*~
\#*\#
/.emacs.desktop
/.emacs.desktop.lock
*.elc
auto-save-list
tramp
.\#*
.org-id-locations
*_archive
*_flymake.*
/eshell/history
/eshell/lastdir
/elpa/
*.rel
/auto/
.cask/
dist/
flycheck_*.el
/server/
.projectile
.dir-locals.el
/network-security.data)";
}

// Project type specific templates
std::string GitUtils::getGameDevGitignoreTemplate() {
    return R"(# Game Development
*.pdb
*.idb
*.ilk
*.map
*.dmp
*.tmp
*.log
*.tlog
*.lastbuildstate
*.iobj
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp_proj
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Game assets (large files)
*.fbx
*.blend1
*.blend2
*.max
*.3ds
*.maya
*.mb
*.ma
*.psd
*.tga
*.exr
*.hdr
*.wav
*.mp3
*.ogg
*.flac)";
}

std::string GitUtils::getWebServiceGitignoreTemplate() {
    return R"(# Web Service specific
*.log
logs/
*.pid
*.seed
*.pid.lock
.npm
.eslintcache
.nyc_output
.grunt
bower_components
.lock-wscript
build/Release
node_modules/
jspm_packages/
typings/
.npm
.eslintcache
.nyc_output
.grunt
bower_components
.lock-wscript
build/Release
.vscode
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json
pids
*.pid
*.seed
*.pid.lock
libpeerconnection.log
coverage
*.lcov
.nyc_output
.grunt
.lock-wscript
build/Release
node_modules/
jspm_packages/
web_modules/
*.tsbuildinfo
.npm
.eslintcache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/
.cache
.parcel-cache
.next
out
.nuxt
dist
.cache/
.vuepress/dist
.serverless/
.fusebox/
.dynamodb/
.tern-port
.vscode-test
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Database
*.db
*.sqlite
*.sqlite3
data/
database/)";
}

std::string GitUtils::getEmbeddedGitignoreTemplate() {
    return R"(# Embedded Development
*.hex
*.bin
*.elf
*.map
*.lst
*.sym
*.lss
*.eep
*.srec
*.ihex
*.uf2
*.dfu
*.axf
*.out
*.d
*.su
*.cyclo
*.i
*.s
*.size
*.objdump
*.readelf
*.nm
*.strings
*.addr2line
*.gdb_history
.gdbinit
*.jlink
*.uvguix.*
*.uvoptx
*.uvprojx
*.dep
*.eww
*.ewt
*.ewd
*.wsdt
*.dni
*.wspos
*.dbgdt
*.cspy.*
*.tmp
*.bak
*.swp
*~.nib
*.pbxuser
*.perspective
*.perspectivev3
*.mode1v3
*.mode2v3
xcuserdata/
*.moved-aside
DerivedData/
.idea/
*.hmap
*.ipa
*.xcscmblueprint
*.xccheckout
*.xcworkspace/
!*.xcworkspace/contents.xcworkspacedata
!*.xcworkspace/xcshareddata/
!*.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist)";
}

std::string GitUtils::getLibraryGitignoreTemplate() {
    return R"(# Library specific
*.a
*.lib
*.so
*.so.*
*.dylib
*.dll
*.pdb
*.exp
*.ilk
*.idb
*.manifest
*.res
*.rc
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Package files
*.tar.gz
*.tar.bz2
*.tar.xz
*.zip
*.7z
*.rar
*.deb
*.rpm
*.pkg
*.dmg
*.msi
*.msm
*.msp
*.nupkg
*.snupkg)";
}

// Testing framework template
std::string GitUtils::getTestingGitignoreTemplate() {
    return R"(# Testing frameworks
test_results/
test_reports/
coverage/
*.gcov
*.gcda
*.gcno
*.info
*.profdata
*.profraw
lcov.info
coverage.xml
coverage.json
htmlcov/
.coverage
.coverage.*
.cache
.pytest_cache/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/)";
}

// CI/CD template
std::string GitUtils::getCICDGitignoreTemplate() {
    return R"(# CI/CD
.github/
.gitlab-ci.yml
.travis.yml
appveyor.yml
azure-pipelines.yml
.circleci/
.jenkins/
Jenkinsfile
.buildkite/
.drone.yml
.semaphore/
.wercker.yml
.codeship-services.yml
.codeship-steps.yml
.codefresh.yml
.buddy/
.teamcity/
.vsts-ci.yml
.azure/
.github/workflows/
.gitlab/
bitbucket-pipelines.yml
.bitbucket/
.scrutinizer.yml
.styleci.yml
.php_cs.cache
.php_cs.dist
.phpunit.result.cache
phpunit.xml
phpunit.xml.dist
.phpunit.cache
testdox.html
.env.testing
.env.dusk.local
.env.dusk.testing
.env.example)";
}

// Operating system template
std::string GitUtils::getOSGitignoreTemplate() {
    return R"(# Operating System Files

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
*.tmp
*.temp
*.swp
*.swo
*~
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msix
*.msm
*.msp
*.lnk

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Linux
*~
.fuse_hidden*
.directory
.Trash-*
.nfs*

# Backup files
*.bak
*.backup
*.old
*.orig
*.save
*.tmp
*.temp
*~
.#*
#*#)";
}

// Branch management implementations
bool GitUtils::createBranch(const std::filesystem::path& projectPath, const std::string& branchName) {
    try {
        if (!executeGitCommand(projectPath, {"checkout", "-b", branchName})) {
            spdlog::error("Failed to create branch: {}", branchName);
            return false;
        }
        spdlog::info("Created branch: {}", branchName);
        return true;
    } catch (const std::exception& e) {
        spdlog::error("Error creating branch {}: {}", branchName, e.what());
        return false;
    }
}

bool GitUtils::switchBranch(const std::filesystem::path& projectPath, const std::string& branchName) {
    try {
        if (!executeGitCommand(projectPath, {"checkout", branchName})) {
            spdlog::error("Failed to switch to branch: {}", branchName);
            return false;
        }
        spdlog::info("Switched to branch: {}", branchName);
        return true;
    } catch (const std::exception& e) {
        spdlog::error("Error switching to branch {}: {}", branchName, e.what());
        return false;
    }
}

// Remote management implementation
bool GitUtils::addRemote(const std::filesystem::path& projectPath,
                        const std::string& remoteName,
                        const std::string& remoteUrl) {
    try {
        if (!executeGitCommand(projectPath, {"remote", "add", remoteName, remoteUrl})) {
            spdlog::error("Failed to add remote {} -> {}", remoteName, remoteUrl);
            return false;
        }
        spdlog::info("Added remote {} -> {}", remoteName, remoteUrl);
        return true;
    } catch (const std::exception& e) {
        spdlog::error("Error adding remote {}: {}", remoteName, e.what());
        return false;
    }
}

// Git hook template implementations
std::string GitUtils::getPreCommitHookTemplate() {
    return R"(#!/bin/sh
# Pre-commit hook for C++ projects
# Generated by CPP-Scaffold

# Check for C++ style issues
echo "Running pre-commit checks..."

# Check for trailing whitespace
if git diff --cached --check; then
    echo "✓ No trailing whitespace found"
else
    echo "✗ Trailing whitespace found. Please fix before committing."
    exit 1
fi

# Check for large files (>10MB)
for file in $(git diff --cached --name-only); do
    if [ -f "$file" ]; then
        size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo 0)
        if [ "$size" -gt 10485760 ]; then
            echo "✗ File $file is larger than 10MB. Consider using Git LFS."
            exit 1
        fi
    fi
done

echo "✓ Pre-commit checks passed"
exit 0
)";
}

std::string GitUtils::getPrePushHookTemplate() {
    return R"(#!/bin/sh
# Pre-push hook for C++ projects
# Generated by CPP-Scaffold

echo "Running pre-push checks..."

# Check if we're pushing to main/master
protected_branch='main'
current_branch=$(git symbolic-ref HEAD | sed -e 's,.*/\(.*\),\1,')

if [ "$current_branch" = "$protected_branch" ]; then
    echo "✓ Pushing to $protected_branch branch"

    # Run tests if available
    if [ -f "CMakeLists.txt" ] && [ -d "build" ]; then
        echo "Running tests..."
        cd build
        if command -v ctest >/dev/null 2>&1; then
            if ! ctest --output-on-failure; then
                echo "✗ Tests failed. Push aborted."
                exit 1
            fi
            echo "✓ All tests passed"
        fi
        cd ..
    fi
fi

echo "✓ Pre-push checks passed"
exit 0
)";
}

std::string GitUtils::getCommitMsgHookTemplate() {
    return R"(#!/bin/sh
# Commit message hook for C++ projects
# Generated by CPP-Scaffold

commit_regex='^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .{1,50}'

if ! grep -qE "$commit_regex" "$1"; then
    echo "Invalid commit message format!"
    echo "Format: type(scope): description"
    echo "Types: feat, fix, docs, style, refactor, test, chore"
    echo "Example: feat(parser): add support for new syntax"
    exit 1
fi

echo "✓ Commit message format is valid"
exit 0
)";
}

} // namespace utils
